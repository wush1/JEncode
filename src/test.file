
{-
((:x
	(x * x) infix
) IO) (square 1 ->) def)


{} gets evaluated instantly 
() pushes a list to the stack

the : mounts a list of code to a name so that it will be evaluated when called

example

(:x
	x x *
) :square

IO is a wrapper in where impure functions can be called.

-}

(
	pushSplit name$
	code$
	code (name ;) eval
) def$


(
	x$
	x x *
) (square) def


(a; func; b;
	
	a b func
) infix;

(:x
	x x *
) :square

(:name
	"Hello " name "!" ++
) :greet


((
	"Input name: " put
	{readLine greet "\n" ++} put
	{(10 11 230 538) (square) map} put
) IO) :main

main


double = \x -> (+ x x)

doIO = IO (do
	let
		line = getLine;
	in
		put (double (toInt line));
	)


zero = \x y -> y
one	 = \x y -> x y



<name> = <expr> --Assign

\a b -> + a b -- lambdas

IO (<expr>) -- IO wrapper where put and get can be called

put <expr> -- puts number as char
get -- read char as number


double = \a -> + a a;

main = IOWrap [
	put ['H', 'e', 'l', 'l', 'o'],
	put (double 10)
	];

main

